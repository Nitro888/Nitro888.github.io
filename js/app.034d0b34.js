(function(e){function n(n){for(var o,s,i=n[0],l=n[1],d=n[2],u=0,p=[];u<i.length;u++)s=i[u],a[s]&&p.push(a[s][0]),a[s]=0;for(o in l)Object.prototype.hasOwnProperty.call(l,o)&&(e[o]=l[o]);c&&c(n);while(p.length)p.shift()();return r.push.apply(r,d||[]),t()}function t(){for(var e,n=0;n<r.length;n++){for(var t=r[n],o=!0,i=1;i<t.length;i++){var l=t[i];0!==a[l]&&(o=!1)}o&&(r.splice(n--,1),e=s(s.s=t[0]))}return e}var o={},a={app:0},r=[];function s(n){if(o[n])return o[n].exports;var t=o[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,s),t.l=!0,t.exports}s.m=e,s.c=o,s.d=function(e,n,t){s.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},s.r=function(e){"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,n){if(1&n&&(e=s(e)),8&n)return e;if(4&n&&"object"===typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(s.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var o in e)s.d(t,o,function(n){return e[n]}.bind(null,o));return t},s.n=function(e){var n=e&&e.__esModule?function(){return e["default"]}:function(){return e};return s.d(n,"a",n),n},s.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},s.p="/";var i=window["webpackJsonp"]=window["webpackJsonp"]||[],l=i.push.bind(i);i.push=n,i=i.slice();for(var d=0;d<i.length;d++)n(i[d]);var c=l;r.push([0,"chunk-vendors"]),t()})({0:function(e,n,t){e.exports=t("56d7")},"0bf1":function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./ERC721.sol";\nimport "../../access/roles/MinterRole.sol";\n\n/**\n * @title ERC721Mintable\n * @dev ERC721 minting logic\n */\ncontract ERC721Mintable is ERC721, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n}\n'},1:function(e,n){},"101c":function(e,n){e.exports="pragma solidity ^0.5.2;\n\nimport \"./IERC165.sol\";\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /*\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor () internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"},1359:function(e,n){e.exports={address:"0x668Fadc48337Cb191332aB21fE6e3576E2E45294",abi:[{constant:!1,inputs:[],name:"build",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_keySet",type:"address[3]"},{name:"_uid",type:"bytes32"}],name:"create",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_keySet",type:"address[3]"},{name:"_uid",type:"bytes32"}],name:"issue",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_key",type:"address"}],name:"newKey",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_issuer",type:"address"},{name:"_key",type:"address"}],name:"proxyAdd",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_issuer",type:"address"},{name:"_key",type:"address"}],name:"proxyRemove",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_user",type:"address"},{name:"_msgPack",type:"bytes"}],name:"register",outputs:[],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_key",type:"address"}],name:"updatePayment",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{constant:!1,inputs:[{name:"_key",type:"address"}],name:"updateVerify",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"nonpayable",type:"function"},{anonymous:!1,inputs:[{indexed:!0,name:"_user",type:"address"},{indexed:!0,name:"_avatar",type:"address"},{indexed:!1,name:"_msgPack",type:"bytes"}],name:"USER",type:"event"},{constant:!0,inputs:[{name:"_uid",type:"bytes32"}],name:"accountByUID",outputs:[{name:"",type:"address"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"accounts",outputs:[{name:"",type:"uint256[2]"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_account",type:"address"}],name:"isAccount",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_issuer",type:"address"}],name:"isIssuer",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_issuer",type:"address"},{name:"_account",type:"address"}],name:"isMember",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_who",type:"address"}],name:"isMember",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_account",type:"address"},{name:"_key",type:"address"}],name:"isPayment",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_issuer",type:"address"},{name:"_proxy",type:"address"}],name:"isProxy",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[{name:"_account",type:"address"},{name:"_key",type:"address"}],name:"isVerify",outputs:[{name:"",type:"bool"}],payable:!1,stateMutability:"view",type:"function"},{constant:!0,inputs:[],name:"members",outputs:[{name:"",type:"uint256"}],payable:!1,stateMutability:"view",type:"function"}]}},"1a16":function(e,n){e.exports="pragma solidity ^0.5.2;\n\nimport \"./IERC721Enumerable.sol\";\nimport \"./ERC721.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n    /*\n     * 0x780e9d63 ===\n     *     bytes4(keccak256('totalSupply()')) ^\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner));\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n"},2:function(e,n){},2347:function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "../math/SafeMath.sol";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library\'s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n'},3:function(e,n){},"38c0":function(e,n,t){"use strict";var o=t("3bdf"),a=t.n(o);a.a},"3bdf":function(e,n,t){},4:function(e,n){},"412a":function(e,n,t){"use strict";var o=t("5298"),a=t.n(o);a.a},"433d":function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./IERC721.sol";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n'},"4dcc":function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "../../introspection/IERC165.sol";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n'},5298:function(e,n,t){},"56d7":function(e,n,t){"use strict";t.r(n);t("cadf"),t("551c"),t("f751"),t("097d");var o=t("2b0e"),a=t("bb71");t("da64");o["a"].use(a["a"],{iconfont:"md"});var r=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-app",{attrs:{dark:""}},[t("v-toolbar",{attrs:{app:"",flat:""}},[t("v-toolbar-title",{staticClass:"headline text-uppercase",domProps:{innerHTML:e._s(e.title)}}),t("v-spacer"),t("v-btn",{attrs:{flat:"",icon:"",href:"https://github.com/Nitro888/DaoAuth",target:"_blank"}},[t("v-icon",[e._v("fab fa-github")])],1),t("v-menu",{attrs:{"offset-y":""},scopedSlots:e._u([{key:"activator",fn:function(n){var o=n.on;return[t("v-btn",e._g({attrs:{flat:"",icon:""}},o),[e._v("\n          "+e._s(e.select)+"\n        ")])]}}])},[t("v-list",e._l(e.items,function(n,o){return t("v-list-tile",{key:o,on:{click:function(n){return e.change(o)}}},[t("v-list-tile-title",[e._v(e._s(o))])],1)}),1)],1)],1),t("v-footer",{attrs:{app:"",height:"auto"}},[t("v-card",{staticClass:"flex site-footer",attrs:{flat:""}},[t("v-card-actions",{staticClass:"justify-center",domProps:{innerHTML:e._s(e.footer)}})],1)],1),t("v-content",[t("Home",{attrs:{contents:e.contents}})],1)],1)},s=[],i=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-container",[e._l(e.contents,function(n,o){return t("div",{key:o},[t("div",{staticClass:"headline white--text font-weight-light text-xs-center",domProps:{innerHTML:e._s(n.title)}}),t("div",{staticClass:"body-2 mb-5 text-xs-center font-weight-thin nanum-gothic",domProps:{innerHTML:e._s(n.content)}})])}),t("h1",{staticClass:"white--text font-weight-light display-1 mt-5 text-xs-center"},[e._v("DaoAuth")]),t("v-divider",{staticClass:"mb-3 mt-3"}),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md4:""}},[t("div",{staticClass:"headline font-weight-light"},[e._v("Issuer Account")]),t("div",{staticClass:"body-2 mb-3 font-weight-thin"},[e._v(e._s(e.member.issuers)+"/"+e._s(e.member.accounts))])]),t("v-flex",{attrs:{md8:""}},[t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Create Issuer Account")])]},proxy:!0}])},[t("v-container",[t("v-form",{ref:"formCreate",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[t("v-text-field",{staticClass:"address-small",attrs:{label:"Master",rules:[e.rules.isAddress]},model:{value:e.create.master,callback:function(n){e.$set(e.create,"master",n)},expression:"create.master"}}),t("v-text-field",{staticClass:"address-small",attrs:{label:"Payment",rules:[e.rules.isAddress]},model:{value:e.create.payment,callback:function(n){e.$set(e.create,"payment",n)},expression:"create.payment"}}),t("v-text-field",{staticClass:"address-small",attrs:{label:"Verify",rules:[e.rules.isAddress]},model:{value:e.create.verify,callback:function(n){e.$set(e.create,"verify",n)},expression:"create.verify"}}),t("v-text-field",{staticClass:"address-small",attrs:{label:"UID",rules:[e.rules.min]},model:{value:e.create.uid,callback:function(n){e.$set(e.create,"uid",n)},expression:"create.uid"}}),t("v-text-field",{staticClass:"address-small",attrs:{label:"Account",loading:e.loading,readonly:""},model:{value:e.create.account,callback:function(n){e.$set(e.create,"account",n)},expression:"create.account"}}),t("v-spacer"),t("v-spacer"),t("v-spacer")],1),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:""},on:{click:e.createIssuer}},[e._v("Create")])],1)],1)],1),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Add Issuer Proxy Keys")])]},proxy:!0}])},[t("v-container",[t("v-form",{ref:"formAdd",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[t("v-text-field",{staticClass:"address-small",attrs:{label:"Account",rules:[e.rules.isAddress]},model:{value:e.add.account,callback:function(n){e.$set(e.add,"account",n)},expression:"add.account"}}),t("v-text-field",{staticClass:"address-small",attrs:{label:"UID",rules:[e.rules.isAddress]},model:{value:e.add.proxyKey,callback:function(n){e.$set(e.add,"proxyKey",n)},expression:"add.proxyKey"}})],1),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:""},on:{click:e.addProxy}},[e._v("Add")])],1)],1)],1),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Remove Issuer Proxy Keys")])]},proxy:!0}])},[t("v-container",[t("v-form",{ref:"formRemove",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[t("v-text-field",{staticClass:"address-small",attrs:{label:"Account",rules:[e.rules.isAddress]},model:{value:e.remove.account,callback:function(n){e.$set(e.remove,"account",n)},expression:"remove.account"}}),t("v-text-field",{staticClass:"address-small",attrs:{label:"UID",rules:[e.rules.isAddress]},model:{value:e.remove.proxyKey,callback:function(n){e.$set(e.remove,"proxyKey",n)},expression:"remove.proxyKey"}})],1),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:""},on:{click:e.removeProxy}},[e._v("Remove")])],1)],1)],1)],1)],1)],1),t("v-divider",{staticClass:"mb-5 mt-3"}),t("h1",{staticClass:"white--text font-weight-light display-1 text-xs-center"},[e._v("FACTORY")]),t("v-divider",{staticClass:"mb-3 mt-3"}),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{lg4:""}},[t("div",{staticClass:"headline mb-3 font-weight-light"},[e._v("Token Factory")])]),t("v-flex",{attrs:{lg8:""}},[t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("ERC 20")])]},proxy:!0}])},[t("v-container",[t("ERC20",{ref:"erc20"}),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:""},on:{click:e.createErc20}},[e._v("Create")])],1)],1)],1),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("ERC 721")])]},proxy:!0}])},[t("v-container",[t("ERC721",{ref:"erc721"}),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:""},on:{click:e.createErc721}},[e._v("Create")])],1)],1)],1)],1)],1)],1),t("v-divider",{staticClass:"mb-5 mt-3"}),t("h1",{staticClass:"white--text font-weight-light display-1 text-xs-center"},[e._v("CODE")]),t("v-divider",{staticClass:"mb-3 mt-3"}),t("ABI",{ref:"abi",on:{call:e.call,send:e.send}})],2)},l=[],d=(t("6b54"),function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-card",{attrs:{flat:""}},[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{xs6:""}},[t("v-radio-group",{attrs:{mandatory:!1},on:{change:e.select},model:{value:e.token.select,callback:function(n){e.$set(e.token,"select",n)},expression:"token.select"}},[t("v-radio",{attrs:{label:"ERC20 (default)",value:"ERC20"}}),t("v-radio",{attrs:{label:"ERC20 (burnable)",value:"ERC20Burnable"}}),t("v-radio",{attrs:{label:"ERC20 (mintable)",value:"ERC20Mintable"}})],1)],1),t("v-flex",{attrs:{xs6:""}},[t("v-text-field",{attrs:{label:"Token Name",readonly:""},model:{value:e.token.name,callback:function(n){e.$set(e.token,"name",n)},expression:"token.name"}}),t("v-text-field",{attrs:{label:"Token Symbol"},model:{value:e.token.symbol,callback:function(n){e.$set(e.token,"symbol",n)},expression:"token.symbol"}}),t("v-text-field",{attrs:{label:"Token Initial Supply",type:"number"},model:{value:e.token.initialSupply,callback:function(n){e.$set(e.token,"initialSupply",n)},expression:"token.initialSupply"}})],1)],1)],1)}),c=[],u=t("f499"),p=t.n(u),f=(t("7f7f"),t("96cf"),t("3b8d")),m=t("8e01"),h=t.n(m),v=t("cdd3"),b=t.n(v),k=t("b20d"),w=t.n(k),y=t("7ea8"),g=t.n(y),I=t("5b00"),_=t.n(I),x=t("8d49"),C=t.n(x),R=t("9300"),E=t.n(R),T=t("fd18"),A=t.n(T),M=t("92a3"),D=M(window.Module),S={ERC20:{"math/SafeMath.sol":{content:h.a},"IERC20.sol":{content:g.a},"ERC20Detailed.sol":{content:C.a},"ERC20.sol":{content:_.a},Deploy:{content:""}},ERC20Burnable:{"math/SafeMath.sol":{content:h.a},"IERC20.sol":{content:g.a},"ERC20Detailed.sol":{content:C.a},"ERC20.sol":{content:_.a},"ERC20Burnable.sol":{content:E.a},Deploy:{content:""}},ERC20Mintable:{"math/SafeMath.sol":{content:h.a},"IERC20.sol":{content:g.a},"ERC20Detailed.sol":{content:C.a},"ERC20.sol":{content:_.a},"access/Roles.sol":{content:b.a},"access/roles/MinterRole.sol":{content:w.a},"ERC20Mintable.sol":{content:A.a},Deploy:{content:""}}},F={data:function(){return{token:{select:"ERC20",name:"My Token",symbol:"XMT",byteCode:null,initialSupply:1e7}}},methods:{select:function(){var e=Object(f["a"])(regeneratorRuntime.mark(function e(n){return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:case"end":return e.stop()}},e)}));function n(n){return e.apply(this,arguments)}return n}(),customize:function(){var e=this.token.select,n=S[e];return n["Deploy"]["content"]='\n        pragma solidity ^0.5.2;\n        import "./'.concat(e,'.sol";\n        import "./ERC20Detailed.sol";\n        contract My').concat(e," is ").concat(e,", ERC20Detailed {\n            uint8 public constant DECIMALS = 18;\n            uint256 public constant INITIAL_SUPPLY = ").concat(this.token.initialSupply,' * (10 ** uint256(DECIMALS));\n            constructor () public ERC20Detailed("').concat(this.token.name,'", "').concat(this.token.symbol,'", DECIMALS) {\n                _mint(msg.sender, INITIAL_SUPPLY);\n            }\n        }'),n},compile:function(){var e={language:"Solidity",sources:this.customize(),settings:{optimizer:{enabled:!0,runs:200},outputSelection:{"*":{"*":["*"]}}}},n=JSON.parse(D.compile(p()(e)));return this.token.byteCode="0x"+n.contracts.Deploy["My".concat(this.token.select)].evm.bytecode.object,{abi:n.contracts.Deploy["My".concat(this.token.select)].abi,option:{data:this.token.byteCode}}}}},O=F,V=t("2877"),q=t("6544"),P=t.n(q),j=t("b0af"),B=t("0e8f"),N=t("a722"),$=t("67b6"),U=t("43a6"),L=t("2677"),z=Object(V["a"])(O,d,c,!1,null,null,null),K=z.exports;P()(z,{VCard:j["a"],VFlex:B["a"],VLayout:N["a"],VRadio:$["a"],VRadioGroup:U["a"],VTextField:L["a"]});var G=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-card",{attrs:{flat:""}},[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{xs6:""}},[t("v-radio-group",{attrs:{mandatory:!1},on:{change:e.select},model:{value:e.token.select,callback:function(n){e.$set(e.token,"select",n)},expression:"token.select"}},[t("v-radio",{attrs:{label:"ERC721 (default)",value:"ERC721"}}),t("v-radio",{attrs:{label:"ERC721 (burnable)",value:"ERC721Burnable"}}),t("v-radio",{attrs:{label:"ERC721 (mintable)",value:"ERC721Mintable"}})],1)],1),t("v-flex",{attrs:{xs6:""}},[t("v-text-field",{attrs:{label:"Token Name",readonly:""},model:{value:e.token.name,callback:function(n){e.$set(e.token,"name",n)},expression:"token.name"}}),t("v-text-field",{attrs:{label:"Token Symbol"},model:{value:e.token.symbol,callback:function(n){e.$set(e.token,"symbol",n)},expression:"token.symbol"}})],1)],1)],1)},H=[],J=t("f1c6"),Y=t.n(J),X=t("2347"),W=t.n(X),Q=t("f684"),Z=t.n(Q),ee=t("101c"),ne=t.n(ee),te=t("4dcc"),oe=t.n(te),ae=t("5845"),re=t.n(ae),se=t("433d"),ie=t.n(se),le=t("8018"),de=t.n(le),ce=t("b4c8"),ue=t.n(ce),pe=t("1a16"),fe=t.n(pe),me=t("f0fc"),he=t.n(me),ve=t("f653"),be=t.n(ve),ke=t("0bf1"),we=t.n(ke),ye=t("92a3"),ge=ye(window.Module),Ie={ERC721:{"IERC721.sol":{content:oe.a},"IERC721Receiver.sol":{content:re.a},"IERC721Enumerable.sol":{content:ie.a},"IERC721Metadata.sol":{content:de.a},"math/SafeMath.sol":{content:h.a},"utils/Address.sol":{content:Y.a},"drafts/Counters.sol":{content:W.a},"introspection/IERC165.sol":{content:Z.a},"introspection/ERC165.sol":{content:ne.a},"ERC721.sol":{content:ue.a},"ERC721Enumerable.sol":{content:fe.a},"ERC721Metadata.sol":{content:he.a},Deploy:{content:""}},ERC721Burnable:{"IERC721.sol":{content:oe.a},"IERC721Receiver.sol":{content:re.a},"IERC721Enumerable.sol":{content:ie.a},"IERC721Metadata.sol":{content:de.a},"math/SafeMath.sol":{content:h.a},"utils/Address.sol":{content:Y.a},"drafts/Counters.sol":{content:W.a},"introspection/IERC165.sol":{content:Z.a},"introspection/ERC165.sol":{content:ne.a},"ERC721.sol":{content:ue.a},"ERC721Enumerable.sol":{content:fe.a},"ERC721Metadata.sol":{content:he.a},"ERC721Burnable.sol":{content:be.a},Deploy:{content:""}},ERC721Mintable:{"IERC721.sol":{content:oe.a},"IERC721Receiver.sol":{content:re.a},"IERC721Enumerable.sol":{content:ie.a},"IERC721Metadata.sol":{content:de.a},"math/SafeMath.sol":{content:h.a},"utils/Address.sol":{content:Y.a},"drafts/Counters.sol":{content:W.a},"introspection/IERC165.sol":{content:Z.a},"introspection/ERC165.sol":{content:ne.a},"ERC721.sol":{content:ue.a},"ERC721Enumerable.sol":{content:fe.a},"ERC721Metadata.sol":{content:he.a},"access/Roles.sol":{content:b.a},"access/roles/MinterRole.sol":{content:w.a},"ERC721Mintable.sol":{content:we.a},Deploy:{content:""}}},_e={data:function(){return{token:{select:"ERC721",name:"My Token",symbol:"XMT",byteCode:null,output:null}}},methods:{select:function(){var e=Object(f["a"])(regeneratorRuntime.mark(function e(n){return regeneratorRuntime.wrap(function(e){while(1)switch(e.prev=e.next){case 0:case"end":return e.stop()}},e)}));function n(n){return e.apply(this,arguments)}return n}(),customize:function(){var e=this.token.select,n=Ie[e];return n["Deploy"]["content"]="\n        pragma solidity ^0.5.2;\n        import './".concat(e,'.sol\';\n        import "./ERC721Enumerable.sol";\n        import "./ERC721Metadata.sol";\n        contract My').concat(e," is ").concat(e,', ERC721Enumerable, ERC721Metadata {\n            constructor () public ERC721Metadata("').concat(this.token.name,'", "').concat(this.token.symbol,'") {}\n        }'),n},compile:function(){var e={language:"Solidity",sources:this.customize(),settings:{optimizer:{enabled:!0,runs:200},outputSelection:{"*":{"*":["*"]}}}},n=JSON.parse(ge.compile(p()(e)));return this.token.byteCode="0x"+n.contracts.Deploy["My".concat(this.token.select)].evm.bytecode.object,{abi:n.contracts.Deploy["My".concat(this.token.select)].abi,option:{data:this.token.byteCode}}}}},xe=_e,Ce=Object(V["a"])(xe,G,H,!1,null,null,null),Re=Ce.exports;P()(Ce,{VCard:j["a"],VFlex:B["a"],VLayout:N["a"],VRadio:$["a"],VRadioGroup:U["a"],VTextField:L["a"]});var Ee=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{xs4:""}},[t("div",{staticClass:"headline font-weight-light"},[e._v("Contract")])]),t("v-flex",{attrs:{xs8:""}},[t("v-form",[t("v-text-field",{staticClass:"mono",attrs:{label:"Contract Address"},model:{value:e.address,callback:function(n){e.address=n},expression:"address"}}),t("v-layout",{attrs:{"justify-end":""}},[t("v-btn",{attrs:{flat:""},on:{click:function(n){return n.stopPropagation(),e.load()}}},[e._v("Load")])],1)],1)],1)],1),t("v-divider",{staticClass:"mb-3 mt-3"}),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{xs4:""}},[t("div",{staticClass:"headline font-weight-light"},[e._v("Source")])]),t("v-flex",{attrs:{xs8:""}},[t("v-form",[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{xs6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Contract Name"},model:{value:e.contract.name,callback:function(n){e.$set(e.contract,"name",n)},expression:"contract.name"}})],1),t("v-flex",{attrs:{xs6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Optimization Enabled"},model:{value:e.contract.optimization,callback:function(n){e.$set(e.contract,"optimization",n)},expression:"contract.optimization"}})],1),t("v-flex",{attrs:{xs6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Compiler Version"},model:{value:e.contract.compiler,callback:function(n){e.$set(e.contract,"compiler",n)},expression:"contract.compiler"}})],1),t("v-flex",{attrs:{xs6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Runs (Optimizer)"},model:{value:e.contract.runs,callback:function(n){e.$set(e.contract,"runs",n)},expression:"contract.runs"}})],1)],1)],1),t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Source")])]},proxy:!0}])},[t("v-container",[t("v-text-field",{staticClass:"mono",attrs:{readonly:"",label:"Swarm Source"},model:{value:e.contract.swarm,callback:function(n){e.$set(e.contract,"swarm",n)},expression:"contract.swarm"}}),t("v-textarea",{staticClass:"mono-small",attrs:{readonly:"",outline:"",rows:"25",label:"Contract Source Code",value:e.contract.code}})],1)],1)],1)],1)],1),t("v-divider",{staticClass:"mb-3 mt-3"}),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{xs4:""}},[t("div",{staticClass:"headline font-weight-light"},[e._v("ABI")])]),t("v-flex",{attrs:{xs8:""}},[t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Json")])]},proxy:!0}])},[t("v-container",[t("v-textarea",{staticClass:"mono-small",attrs:{readonly:"",outline:"",rows:"10",label:"Contract ABI",value:e.contract.abi}})],1)],1),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Function")])]},proxy:!0}])},[t("v-container",[t("v-list",{attrs:{"two-line":"",subheader:""}},e._l(e.ncf,function(n,o){return t("v-list-tile",{key:o,on:{click:function(t){return e.runNCF(n.obj)}}},[t("v-list-tile-content",[t("v-list-tile-title",{staticClass:"mono"},[e._v(e._s(n.title))]),t("v-list-tile-sub-title",[n.payable?t("v-chip",{attrs:{label:"",disabled:"",color:"red","text-color":"white"}},[e._v("Payable")]):e._e(),t("span",{staticClass:"mono"},[e._v(e._s(n.returns))])],1)],1)],1)}),1)],1)],1),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Constant Function")])]},proxy:!0}])},[t("v-container",[t("v-list",{attrs:{"two-line":"",subheader:""}},e._l(e.cf,function(n,o){return t("v-list-tile",{key:o,on:{click:function(t){return e.runCF(n.obj)}}},[t("v-list-tile-content",[t("v-list-tile-title",{staticClass:"mono"},[e._v(e._s(n.title))]),t("v-list-tile-sub-title",[n.payable?t("v-chip",{attrs:{label:"",disabled:"",color:"red","text-color":"white"}},[e._v("Payable")]):e._e(),t("span",{staticClass:"mono"},[e._v(e._s(n.returns))])],1)],1)],1)}),1)],1)],1),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("Event")])]},proxy:!0}])},[t("v-container",[t("v-list",{attrs:{"two-line":"",subheader:""}},e._l(e.e,function(n,o){return t("v-list-tile",{key:o,attrs:{href:e.getUrl(n.obj),target:"_blank"}},[t("v-list-tile-content",[t("v-list-tile-title",{staticClass:"mono"},[e._v(e._s(n.title))]),t("v-list-tile-sub-title",{staticClass:"mono"},[e._v(e._s(n.returns))])],1)],1)}),1)],1)],1)],1)],1)],1),t("v-divider",{staticClass:"mb-3 mt-3"}),t("v-dialog",{attrs:{persistent:"","max-width":"640"},model:{value:e.dialog.show,callback:function(n){e.$set(e.dialog,"show",n)},expression:"dialog.show"}},[t(e.dialog.body,{tag:"component",attrs:{address:e.address,dialog:e.dialog},on:{hide:function(n){e.dialog.show=!1,e.dialog.body=null,e.dialog.obj=null},call:function(n){return e.$emit("call",n)},send:function(n){return e.$emit("send",n)}}})],1)],1)},Te=[],Ae=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-card",[t("v-card-title",{attrs:{"primary-title":""}},[t("span",{staticClass:"mono font-weight-medium"},[e._v(e._s(e.title))])]),t("v-container",{attrs:{fluid:""}},[t("v-form",{ref:"form",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[e._l(e.agrs,function(n,o){return t("v-text-field",{key:o,staticClass:"mono",attrs:{label:n.label,rules:e.notEmpty,required:""},model:{value:n.model,callback:function(t){e.$set(n,"model",t)},expression:"item.model"}})}),"function"==e.dialog.obj.type&&e.dialog.obj.constant?t("v-textarea",{staticClass:"mono",attrs:{readonly:"",outline:"",label:e.dialog.returns,value:e.result}}):e._e()],2)],1),"function"==e.dialog.obj.type?t("v-layout",[t("v-spacer"),t("v-btn",{attrs:{flat:""},on:{click:function(n){return n.stopPropagation(),e.$emit("hide")}}},[e._v("Close")]),t("v-btn",{attrs:{flat:""},on:{click:function(n){return n.stopPropagation(),e.run(n)}}},[e._v(e._s(e.btn))])],1):e._e()],1)},Me=[],De={props:["address","dialog"],data:function(){return{valid:null,title:"",agrs:[],notEmpty:[function(e){return!!e||"Required."}],result:"",btn:"RUN"}},mounted:function(){this.title=this.dialog.name,this.agrs=[];for(var e=0;e<this.dialog.obj.inputs.length;e++)this.agrs.push({model:"",label:this.dialog.obj.inputs[e].type+" "+this.dialog.obj.inputs[e].name});this.btn=this.dialog.obj.constant?"Call":"Send"},methods:{run:function(){if(this.$refs.form.validate()){var e=window.wallet.abiQR.encodeFunctionCall({to:this.address,json:this.dialog.obj,parms:this.agrs});if(this.dialog.obj.constant){var n=this;this.$emit("call",{callData:{to:e.to,data:e.code},callback:function(e,t){e||(n.result=p()(window.wallet.web3.eth.abi.decodeParameters(n.dialog.obj.outputs,t),null,2))}})}else{var t=this;this.$emit("send",{callData:{to:e.to,data:e.code},callback:function(e,n){e||(t.result=p()(window.wallet.web3.eth.abi.decodeParameters(t.dialog.obj.outputs,n),null,2))}})}}}}},Se=De,Fe=(t("38c0"),t("8336")),Oe=t("12b2"),Ve=t("a523"),qe=t("4bd4"),Pe=t("9910"),je=t("a844"),Be=Object(V["a"])(Se,Ae,Me,!1,null,"c06f8508",null),Ne=Be.exports;P()(Be,{VBtn:Fe["a"],VCard:j["a"],VCardTitle:Oe["a"],VContainer:Ve["a"],VForm:qe["a"],VLayout:N["a"],VSpacer:Pe["a"],VTextField:L["a"],VTextarea:je["a"]});var $e={data:function(){return{address:"",cf:[],ncf:[],e:[],abi:[],source:{},contract:{show:!1,name:"",compiler:"",optimization:"",runs:"",code:"",swarm:"",abi:""},dialog:{run:!1,fullName:"",body:null,obj:null}}},mounted:function(){this.load()},methods:{load:function(){var e=this;this.address&&(this.contract.name="",this.contract.compiler="",this.contract.optimization="",this.contract.runs="",this.contract.code="",this.contract.swarm="",this.contract.abi="",window.wallet.logs.loadSource(this.address).catch(console.log).then(function(n){n.length>0?(e.source=n[0],e.contract.name=e.source.ContractName,e.contract.compiler=e.source.CompilerVersion,e.contract.optimization="1"===e.source.OptimizationUsed?"true":"false",e.contract.runs=e.source.Runs,e.contract.code=e.source.SourceCode,e.contract.swarm=e.source.SwarmSource,e.createInterface()):window.wallet.logs.loadABI(e.address).catch(console.log).then(function(n){e.source.ABI=n,e.createInterface()})}))},createInterface:function(){this.abi=JSON.parse(this.source.ABI),this.contract.abi=p()(this.abi,null,2),this.ui=[];for(var e=0;e<this.abi.length;e++)this.create(this.abi[e])},arguments:function(e){var n="";if("undefined"!==typeof e)for(var t=0;t<e.length;t++)n+=(t>0?", ":"")+e[t].type+("undefined"!==typeof e[t].indexed&&e[t].indexed?" indexed":"")+(""!==e[t].name?" "+e[t].name:"");return"("+n+")"},getName:function(e){return e.name+this.arguments(e.inputs)},create:function(e){var n=e.type+" "+this.getName(e);switch(e.type){case"function":var t=this.arguments(e.outputs);t="()"===t?"":(e.payable?" returns ":"returns ")+t,e.constant?this.cf.push({title:n,returns:t,payable:e.payable,obj:e}):this.ncf.push({title:n,returns:t,payable:e.payable,obj:e});break;case"event":this.e.push({title:n,obj:e});break;default:console.log(e);break}},runNCF:function(e){this.dialog.name=this.getName(e),this.dialog.fullName=e.type+" "+this.dialog.name,this.dialog.obj=e,this.dialog.body=Ne,this.dialog.show=!this.dialog.show},runCF:function(e){this.dialog.name=this.getName(e),this.dialog.fullName=e.type+" "+this.dialog.name,this.dialog.obj=e,this.dialog.body=Ne,this.dialog.returns="returns "+this.arguments(e.outputs),this.dialog.show=!this.dialog.show},runEvent:function(e){var n="topic0="+window.wallet.abiQR.encodeEventSignature(e);window.wallet.logs.getLogs(this.address,n).catch(console.log).then(console.log)},getUrl:function(e){var n="topic0="+window.wallet.abiQR.encodeEventSignature(e);return window.wallet.logs.getUrl(this.address,n)}}},Ue=$e,Le=(t("412a"),t("cc20")),ze=t("169a"),Ke=t("ce7e"),Ge=t("cd55"),He=t("49e2"),Je=t("8860"),Ye=t("ba95"),Xe=t("5d23"),We=Object(V["a"])(Ue,Ee,Te,!1,null,"9230b9bc",null),Qe=We.exports;P()(We,{VBtn:Fe["a"],VChip:Le["a"],VContainer:Ve["a"],VDialog:ze["a"],VDivider:Ke["a"],VExpansionPanel:Ge["a"],VExpansionPanelContent:He["a"],VFlex:B["a"],VForm:qe["a"],VLayout:N["a"],VList:Je["a"],VListTile:Ye["a"],VListTileContent:Xe["a"],VListTileSubTitle:Xe["b"],VListTileTitle:Xe["c"],VTextField:L["a"],VTextarea:je["a"]});var Ze={components:{ERC20:K,ERC721:Re,ABI:Qe},props:["contents"],data:function(){return{valid:null,loading:!1,enable:!1,member:{issuers:0,accounts:0},create:{master:"",payment:"",verify:"",uid:"",account:""},add:{proxyKey:"",account:""},remove:{proxyKey:"",account:""},rules:{isAddress:function(e){return window.wallet.isAddress(e)||"Is not address."},min:function(e){return e.length>=4||"Min 4 characters"}}}},mounted:function(){var e=this;web3&&(this.enable=!0,web3.eth.call({to:window.wallet.daoAuth.address,data:window.wallet.daoAuth.methods.accounts().encodeABI()},function(n,t){n||(t=window.wallet.web3.eth.abi.decodeParameters(["uint256","uint256"],t),e.member.issuers=window.wallet.web3.utils.toBN(t[0]).toString(),e.member.accounts=window.wallet.web3.utils.toBN(t[1]).toString())}))},methods:{sendTransaction:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;web3.eth.accounts.length>0&&web3.eth.sendTransaction({from:web3.eth.accounts[0],to:e,data:n},function(e,n){console.log(e,n),!e&&t&&t(n)})},createIssuer:function(){if(this.$refs.formCreate.validate()&&this.enable){var e=window.wallet.web3.utils.keccak256(this.create.uid);this.sendTransaction(window.wallet.daoAuth.address,window.wallet.daoAuth.methods.create([this.create.master,this.create.payment,this.create.verify],e).encodeABI())}},addProxy:function(){this.$refs.formAdd.validate()&&this.enable&&this.sendTransaction(window.wallet.daoAuth.address,window.wallet.daoAuth.methods.proxyAdd(this.add.account,this.add.proxyKey).encodeABI())},removeProxy:function(){this.$refs.formRemove.validate()&&this.enable&&this.sendTransaction(window.wallet.daoAuth.address,window.wallet.daoAuth.methods.proxyRemove(this.remove.account,this.remove.proxyKey).encodeABI())},deploy:function(e){this.sendTransaction(null,new window.wallet.web3.eth.Contract(e.abi).deploy(e.option).encodeABI())},createErc20:function(){this.deploy(this.$refs.erc20.compile())},createErc721:function(){this.deploy(this.$refs.erc721.compile())},call:function(e){web3.eth.call(e.callData,e.callback)},send:function(e){this.sendTransaction(e.callData.to,e.callData.data,e.callback)}}},en=Ze,nn=(t("632d"),Object(V["a"])(en,i,l,!1,null,"4785140b",null)),tn=nn.exports;P()(nn,{VBtn:Fe["a"],VContainer:Ve["a"],VDivider:Ke["a"],VExpansionPanel:Ge["a"],VExpansionPanelContent:He["a"],VFlex:B["a"],VForm:qe["a"],VLayout:N["a"],VSpacer:Pe["a"],VTextField:L["a"]});var on=[{title:"DaoAuth",content:"DaoAuth는 블록체인을 이용한 탈중앙 인증 수단입니다."},{title:"Account",content:"\n    <strong>공개주소를 이용한 지갑은</strong><br/><br/>\n      프라이빗키 유출에 따른 대응이 불가능하며,<br/>\n      타인에게 양도할 경우, 상호 신뢰의 문제가 있으며,<br/>\n      키를 변경하여 주소가 변경되었을 경우 새주소로 자산의 이전이 불가능하다는 단점등이 있습니다.<br/><br/>\n    <strong>DaoAuth에 의해 만들어진 어카운트는</strong><br/><br/>\n      사용자 암호를 바꾸듯이 사용자가 언제든지 키를 바꿀 수 있으며,<br/>\n      따라서 양도 문제에 있어서도 신뢰의 문제가 사라지게 됩니다.<br/>\n      키를 변경하더라도 주소는 변경이 되지 않기 때문에, 자산이전에 대해 고민할 필요가 없습니다.<br/>"},{title:"Issuer",content:"어카운트를 직접 DaoAuth에서 생성한 사용자를 인증자라고 부릅니다.<br/>\n    인증자들은 사용자들의 요청을 받아 어카운트를 생성해 줄 수 있으며,<br/>\n    이때 인증자는 어카운트를 생성해주는 댓가로 e-mail, 전화번호, 그외 기타 <strong>KYC & AML</strong>에 필요한 정보를 요청할 수 있습니다.<br/>\n    그래서 높은 수준 정보를 요구하는 인증자들이 생성한 어카운트는 거래에 있어서 상대방에게 높은 신뢰를 얻을 수 있습니다."},{title:"User",content:"어카운트를 인증자를 통해 생성한 이용자들을 사용자라고 부릅니다.<br/>\n    그리고 이 어카운트를 이용해 DaoAuth를 지원하는 각종 서비스에 바로 가입하여 이용할 수 있게 됩니다."}],an=on,rn=[{title:"DaoAuth",content:"DaoAuth is a decentralized authentication method using a block chain."},{title:"Account",content:"\n    <strong>Wallet with public address</strong><br/><br/>\n      is not possible to respond to leakage of the private key,<br/>\n      When transferring to another person, there is a problem of mutual trust,<br/>\n      The disadvantage is that if the address is changed by changing the key, the asset can not be transferred to the new address.<br/><br/>\n    <strong>An account created by DaoAuth</strong><br/><br/>\n      As users change their passwords, users can change their keys at any time, <br/>\n      So, even with transfer issues, the problem of trust disappears. <br/>\n      You do not have to worry about transferring assets because you can not change the address even if you change the key.<br/><br/>"},{title:"Issuer",content:"The user who created the account directly from DaoAuth is called the Issuer.<br/>\n    Issuers can generate accounts at the request of users. <br/>\n    At this time, the issuer can ask for information on e-mail, telephone number, and other <strong>KYC & AML</strong> in return for creating an account. <br/>\n    This means that accounts created by issuer who require high-level information can gain a high degree of trust in the transaction."},{title:"User",content:"Who create accounts through an issuer are called users. <br/>\n    You will then be able to sign up for DaoAuth services using this account."}],sn=rn,ln={name:"App",components:{Home:tn},data:function(){return{title:"DaoAuth",items:{KO:an,EN:sn},contents:an,select:"KO",footer:'&copy;2018<span class="ml-1 mr-1 font-weight-black">·</span><strong>daoauth.com</strong>'}},methods:{change:function(e){this.contents=this.items[e]}}},dn=ln,cn=(t("842d"),t("7496")),un=t("99d9"),pn=t("549c"),fn=t("553a"),mn=t("132d"),hn=t("e449"),vn=t("71d9"),bn=t("2a7f"),kn=Object(V["a"])(dn,r,s,!1,null,"27922454",null),wn=kn.exports;P()(kn,{VApp:cn["a"],VBtn:Fe["a"],VCard:j["a"],VCardActions:un["a"],VContent:pn["a"],VFooter:fn["a"],VIcon:mn["a"],VList:Je["a"],VListTile:Ye["a"],VListTileTitle:Xe["c"],VMenu:hn["a"],VSpacer:Pe["a"],VToolbar:vn["a"],VToolbarTitle:bn["a"]});var yn=t("8c4f"),gn=function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-container",[t("h1",[e._v("This is an about page")])])},In=[],_n={},xn=Object(V["a"])(_n,gn,In,!1,null,null,null),Cn=xn.exports;P()(xn,{VContainer:Ve["a"]}),o["a"].use(yn["a"]);var Rn=new yn["a"]({mode:"history",base:"/",routes:[{path:"/",name:"home",component:tn},{path:"/about",name:"about",component:Cn}]}),En=t("2f62");o["a"].use(En["a"]);var Tn=new En["a"].Store({state:{},mutations:{},actions:{}}),An=t("9483");Object(An["a"])("".concat("/","service-worker.js"),{ready:function(){console.log("App is being served from cache by a service worker.\nFor more details, visit https://goo.gl/AFskqB")},registered:function(){console.log("Service worker has been registered.")},cached:function(){console.log("Content has been cached for offline use.")},updatefound:function(){console.log("New content is downloading.")},updated:function(){console.log("New content is available; please refresh.")},offline:function(){console.log("No internet connection found. App is running in offline mode.")},error:function(e){console.error("Error during service worker registration:",e)}});var Mn=t("795b"),Dn=t.n(Mn),Sn=t("1e56"),Fn=t("1fb5"),On=t("e573"),Vn=new On(On.givenProvider||"ws://localhost:8546"),qn=t("1359"),Pn="https://api-ropsten.etherscan.io";window.wallet={web3:Vn,daoAuth:new Vn.eth.Contract(qn.abi,qn.address),isAddress:function(e){return Vn.utils.isAddress(e)},abiQR:{eocode:function(e,n,t,o){return window.wallet.storage.base64.encode({url:e,to:n,json:t,parms:o})},decode:function(e){return window.wallet.storage.base64.decode(e)},encodeFunctionCall:function(e){var n=null;if(""!==e.json.name){for(var t=[],o=0;o<e.parms.length;o++)t.push(e.parms[o].model);n=window.wallet.web3.eth.abi.encodeFunctionCall(e.json,t)}return{to:e.to,code:n}},encodeEventSignature:function(e){return Vn.eth.abi.encodeEventSignature(e)}},logs:{loadABI:function(e){return new Dn.a(function(n,t){var o=Pn+"/api?module=contract&action=getabi&address="+e;window.wallet.utils.loadJson(o).then(function(e){n(e.result)}).catch(t)})},loadSource:function(e){return new Dn.a(function(n,t){var o=Pn+"/api?module=contract&action=getsourcecode&address="+e;window.wallet.utils.loadJson(o).then(function(e){n(e.result)}).catch(t)})},getLogs:function(e,n){return new Dn.a(function(t,o){window.wallet.utils.loadJson(window.wallet.logs.getUrl(e,n)).catch(o).then(function(e){t(e.result)})})},getUrl:function(e,n){var t=Pn+"/api?module=logs&action=getLogs&fromBlock=0&toBlock=latest&address="+e;return""!==n&&(t+="&"+n),t}},utils:{loadJson:function(e){return new Dn.a(function(n,t){var o=new window.XMLHttpRequest;o.onreadystatechange=function(){o.readyState===window.XMLHttpRequest.DONE&&(200===o.status?n(JSON.parse(o.responseText)):t(new Error(o)))},o.open("GET",e,!0),o.send()})}},storage:{base64:{encode:function(e){return Fn.fromByteArray(Sn.encode(e))},decode:function(e){return Sn.decode(Fn.toByteArray(e))}},msgpack:{encode:function(e){return Vn.utils.bytesToHex(Sn.encode(e))},decode:function(e){try{return Sn.decode(Vn.utils.hexToBytes(e))}catch(n){console.log("msgpack error")}return null}}}};window.wallet;o["a"].config.productionTip=!1,new o["a"]({router:Rn,store:Tn,render:function(e){return e(wn)}}).$mount("#app")},5845:function(e,n){e.exports='pragma solidity ^0.5.2;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n'},"5b00":function(e,n){e.exports="pragma solidity ^0.5.2;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://eips.ethereum.org/EIPS/eip-20\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n     * @dev Transfer token to a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Transfer token for a specified addresses\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Approve an address to spend another addresses' tokens.\n     * @param owner The address that owns the tokens.\n     * @param spender The address that will spend the tokens.\n     * @param value The number of tokens that can be spent.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        _allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n    }\n}\n"},"632d":function(e,n,t){"use strict";var o=t("d59a"),a=t.n(o);a.a},"7ea8":function(e,n){e.exports="pragma solidity ^0.5.2;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"},"7ecb":function(e,n,t){},8018:function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./IERC721.sol";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n'},"842d":function(e,n,t){"use strict";var o=t("7ecb"),a=t.n(o);a.a},"8d49":function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./IERC20.sol";\n\n/**\n * @title ERC20Detailed token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @return the symbol of the token.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @return the number of decimals of the token.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n'},"8e01":function(e,n){e.exports="pragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n"},9300:function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./ERC20.sol";\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The account whose tokens will be burned.\n     * @param value uint256 The amount of token to be burned.\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n'},b20d:function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "../Roles.sol";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n'},b4c8:function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./IERC721.sol";\nimport "./IERC721Receiver.sol";\nimport "../../math/SafeMath.sol";\nimport "../../utils/Address.sol";\nimport "../../drafts/Counters.sol";\nimport "../../introspection/ERC165.sol";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /*\n     * 0x80ac58cd ===\n     *     bytes4(keccak256(\'balanceOf(address)\')) ^\n     *     bytes4(keccak256(\'ownerOf(uint256)\')) ^\n     *     bytes4(keccak256(\'approve(address,uint256)\')) ^\n     *     bytes4(keccak256(\'getApproved(uint256)\')) ^\n     *     bytes4(keccak256(\'setApprovalForAll(address,bool)\')) ^\n     *     bytes4(keccak256(\'isApprovedForAll(address,address)\')) ^\n     *     bytes4(keccak256(\'transferFrom(address,address,uint256)\')) ^\n     *     bytes4(keccak256(\'safeTransferFrom(address,address,uint256)\')) ^\n     *     bytes4(keccak256(\'safeTransferFrom(address,address,uint256,bytes)\'))\n     */\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * The call is not executed if the target address is not a contract\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n'},cdd3:function(e,n){e.exports="pragma solidity ^0.5.2;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account's access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n"},d59a:function(e,n,t){},f0fc:function(e,n){e.exports="pragma solidity ^0.5.2;\n\nimport \"./ERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"../../introspection/ERC165.sol\";\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n    /*\n     * 0x5b5e139f ===\n     *     bytes4(keccak256('name()')) ^\n     *     bytes4(keccak256('symbol()')) ^\n     *     bytes4(keccak256('tokenURI(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId));\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token\n     * Reverts if the token ID does not exist\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId));\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"},f1c6:function(e,n){e.exports="pragma solidity ^0.5.2;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n"},f653:function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./ERC721.sol";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\ncontract ERC721Burnable is ERC721 {\n    /**\n     * @dev Burns a specific ERC721 token.\n     * @param tokenId uint256 id of the ERC721 token to be burned.\n     */\n    function burn(uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n        _burn(tokenId);\n    }\n}\n'},f684:function(e,n){e.exports="pragma solidity ^0.5.2;\n\n/**\n * @title IERC165\n * @dev https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"},fd18:function(e,n){e.exports='pragma solidity ^0.5.2;\n\nimport "./ERC20.sol";\nimport "../../access/roles/MinterRole.sol";\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n}\n'}});
//# sourceMappingURL=app.034d0b34.js.map