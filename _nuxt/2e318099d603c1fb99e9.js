(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{758:function(e,n,t){var content=t(794);"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(14).default)("1797f77a",content,!0,{sourceMap:!1})},759:function(e,n,t){var content=t(798);"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(14).default)("5bda3a7a",content,!0,{sourceMap:!1})},760:function(e,n,t){var content=t(812);"string"==typeof content&&(content=[[e.i,content,""]]),content.locals&&(e.exports=content.locals);(0,t(14).default)("212ac18e",content,!0,{sourceMap:!1})},793:function(e,n,t){"use strict";var o=t(758);t.n(o).a},794:function(e,n,t){(e.exports=t(13)(!1)).push([e.i,".mono[data-v-5efd9761]{font-family:Roboto Mono,monospace}",""])},797:function(e,n,t){"use strict";var o=t(759);t.n(o).a},798:function(e,n,t){(e.exports=t(13)(!1)).push([e.i,".mono[data-v-76b38192],.mono-small[data-v-76b38192]{font-family:Roboto Mono,monospace}.mono-small[data-v-76b38192]{font-size:.9em}",""])},811:function(e,n,t){"use strict";var o=t(760);t.n(o).a},812:function(e,n,t){(e.exports=t(13)(!1)).push([e.i,".address[data-v-7a1dbada],.address-small[data-v-7a1dbada]{font-family:Roboto Mono,monospace}.address-small[data-v-7a1dbada]{font-size:.9em}.noto[data-v-7a1dbada]{font-family:Noto Sans KR,sans-serif}",""])},819:function(e,n,t){"use strict";t.r(n);t(111),t(112),t(22),t(37),t(91);var o=t(27),r="pragma solidity ^0.5.2;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n    /**\n     * @dev Multiplies two unsigned integers, reverts on overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n     * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Adds two unsigned integers, reverts on overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a);\n\n        return c;\n    }\n\n    /**\n     * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n     * reverts when dividing by zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}\n",d="pragma solidity ^0.5.2;\n\n/**\n * @title Roles\n * @dev Library for managing addresses assigned to a Role.\n */\nlibrary Roles {\n    struct Role {\n        mapping (address => bool) bearer;\n    }\n\n    /**\n     * @dev give an account access to this role\n     */\n    function add(Role storage role, address account) internal {\n        require(account != address(0));\n        require(!has(role, account));\n\n        role.bearer[account] = true;\n    }\n\n    /**\n     * @dev remove an account's access to this role\n     */\n    function remove(Role storage role, address account) internal {\n        require(account != address(0));\n        require(has(role, account));\n\n        role.bearer[account] = false;\n    }\n\n    /**\n     * @dev check if an account has this role\n     * @return bool\n     */\n    function has(Role storage role, address account) internal view returns (bool) {\n        require(account != address(0));\n        return role.bearer[account];\n    }\n}\n",l='pragma solidity ^0.5.2;\n\nimport "../Roles.sol";\n\ncontract MinterRole {\n    using Roles for Roles.Role;\n\n    event MinterAdded(address indexed account);\n    event MinterRemoved(address indexed account);\n\n    Roles.Role private _minters;\n\n    constructor () internal {\n        _addMinter(msg.sender);\n    }\n\n    modifier onlyMinter() {\n        require(isMinter(msg.sender));\n        _;\n    }\n\n    function isMinter(address account) public view returns (bool) {\n        return _minters.has(account);\n    }\n\n    function addMinter(address account) public onlyMinter {\n        _addMinter(account);\n    }\n\n    function renounceMinter() public {\n        _removeMinter(msg.sender);\n    }\n\n    function _addMinter(address account) internal {\n        _minters.add(account);\n        emit MinterAdded(account);\n    }\n\n    function _removeMinter(address account) internal {\n        _minters.remove(account);\n        emit MinterRemoved(account);\n    }\n}\n',c="pragma solidity ^0.5.2;\n\n/**\n * @title ERC20 interface\n * @dev see https://eips.ethereum.org/EIPS/eip-20\n */\ninterface IERC20 {\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n",m="pragma solidity ^0.5.2;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://eips.ethereum.org/EIPS/eip-20\n * Originally based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n *\n * This implementation emits additional Approval events, allowing applications to reconstruct the allowance status for\n * all accounts just by listening to said events. Note that this isn't required by the specification, and other\n * compliant implementations may not do it.\n */\ncontract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowed;\n\n    uint256 private _totalSupply;\n\n    /**\n     * @dev Total number of tokens in existence\n     */\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev Gets the balance of the specified address.\n     * @param owner The address to query the balance of.\n     * @return An uint256 representing the amount owned by the passed address.\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param owner address The address which owns the funds.\n     * @param spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    /**\n     * @dev Transfer token to a specified address\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function transfer(address to, uint256 value) public returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param spender The address which will spend the funds.\n     * @param value The amount of tokens to be spent.\n     */\n    function approve(address spender, uint256 value) public returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev Transfer tokens from one address to another.\n     * Note that while this function emits an Approval event, this is not required as per the specification,\n     * and other compliant implementations may not emit the event.\n     * @param from address The address which you want to send tokens from\n     * @param to address The address which you want to transfer to\n     * @param value uint256 the amount of tokens to be transferred\n     */\n    function transferFrom(address from, address to, uint256 value) public returns (bool) {\n        _transfer(from, to, value);\n        _approve(from, msg.sender, _allowed[from][msg.sender].sub(value));\n        return true;\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param spender The address which will spend the funds.\n     * @param subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\n        _approve(msg.sender, spender, _allowed[msg.sender][spender].sub(subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Transfer token for a specified addresses\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param value The amount to be transferred.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n        _balances[to] = _balances[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Internal function that mints an amount of the token and assigns it to\n     * an account. This encapsulates the modification of balances such that the\n     * proper events are emitted.\n     * @param account The account that will receive the created tokens.\n     * @param value The amount that will be created.\n     */\n    function _mint(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.add(value);\n        _balances[account] = _balances[account].add(value);\n        emit Transfer(address(0), account, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account.\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burn(address account, uint256 value) internal {\n        require(account != address(0));\n\n        _totalSupply = _totalSupply.sub(value);\n        _balances[account] = _balances[account].sub(value);\n        emit Transfer(account, address(0), value);\n    }\n\n    /**\n     * @dev Approve an address to spend another addresses' tokens.\n     * @param owner The address that owns the tokens.\n     * @param spender The address that will spend the tokens.\n     * @param value The number of tokens that can be spent.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        require(spender != address(0));\n        require(owner != address(0));\n\n        _allowed[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Internal function that burns an amount of the token of a given\n     * account, deducting from the sender's allowance for said account. Uses the\n     * internal burn function.\n     * Emits an Approval event (reflecting the reduced allowance).\n     * @param account The account whose tokens will be burnt.\n     * @param value The amount that will be burnt.\n     */\n    function _burnFrom(address account, uint256 value) internal {\n        _burn(account, value);\n        _approve(account, msg.sender, _allowed[account][msg.sender].sub(value));\n    }\n}\n",f='pragma solidity ^0.5.2;\n\nimport "./IERC20.sol";\n\n/**\n * @title ERC20Detailed token\n * @dev The decimals are only for visualization purposes.\n * All the operations are done using the smallest and indivisible token unit,\n * just as on Ethereum all the operations are done in wei.\n */\ncontract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor (string memory name, string memory symbol, uint8 decimals) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    /**\n     * @return the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @return the symbol of the token.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @return the number of decimals of the token.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n',v=t(763),h=v(window.Module),k={ERC20:{"math/SafeMath.sol":{content:r},"IERC20.sol":{content:c},"ERC20Detailed.sol":{content:f},"ERC20.sol":{content:m},Deploy:{content:""}},ERC20Burnable:{"math/SafeMath.sol":{content:r},"IERC20.sol":{content:c},"ERC20Detailed.sol":{content:f},"ERC20.sol":{content:m},"ERC20Burnable.sol":{content:'pragma solidity ^0.5.2;\n\nimport "./ERC20.sol";\n\n/**\n * @title Burnable Token\n * @dev Token that can be irreversibly burned (destroyed).\n */\ncontract ERC20Burnable is ERC20 {\n    /**\n     * @dev Burns a specific amount of tokens.\n     * @param value The amount of token to be burned.\n     */\n    function burn(uint256 value) public {\n        _burn(msg.sender, value);\n    }\n\n    /**\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\n     * @param from address The account whose tokens will be burned.\n     * @param value uint256 The amount of token to be burned.\n     */\n    function burnFrom(address from, uint256 value) public {\n        _burnFrom(from, value);\n    }\n}\n'},Deploy:{content:""}},ERC20Mintable:{"math/SafeMath.sol":{content:r},"IERC20.sol":{content:c},"ERC20Detailed.sol":{content:f},"ERC20.sol":{content:m},"access/Roles.sol":{content:d},"access/roles/MinterRole.sol":{content:l},"ERC20Mintable.sol":{content:'pragma solidity ^0.5.2;\n\nimport "./ERC20.sol";\nimport "../../access/roles/MinterRole.sol";\n\n/**\n * @title ERC20Mintable\n * @dev ERC20 minting logic\n */\ncontract ERC20Mintable is ERC20, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param value The amount of tokens to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 value) public onlyMinter returns (bool) {\n        _mint(to, value);\n        return true;\n    }\n}\n'},Deploy:{content:""}}},w={data:function(){return{token:{select:"ERC20",name:"My Token",symbol:"XMT",byteCode:null,initialSupply:1e7}}},methods:{select:function(){var e=Object(o.a)(regeneratorRuntime.mark(function e(n){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:case"end":return e.stop()}},e)}));return function(n){return e.apply(this,arguments)}}(),customize:function(){var base=this.token.select,e=k[base];return e.Deploy.content='\n        pragma solidity ^0.5.2;\n        import "./'.concat(base,'.sol";\n        import "./ERC20Detailed.sol";\n        contract My').concat(base," is ").concat(base,", ERC20Detailed {\n            uint8 public constant DECIMALS = 18;\n            uint256 public constant INITIAL_SUPPLY = ").concat(this.token.initialSupply,' * (10 ** uint256(DECIMALS));\n            constructor () public ERC20Detailed("').concat(this.token.name,'", "').concat(this.token.symbol,'", DECIMALS) {\n                _mint(msg.sender, INITIAL_SUPPLY);\n            }\n        }'),e},compile:function(){var e={language:"Solidity",sources:this.customize(),settings:{optimizer:{enabled:!0,runs:200},outputSelection:{"*":{"*":["*"]}}}},output=JSON.parse(h.compile(JSON.stringify(e)));return this.token.byteCode="0x"+output.contracts.Deploy["My".concat(this.token.select)].evm.bytecode.object,{abi:output.contracts.Deploy["My".concat(this.token.select)].abi,option:{data:this.token.byteCode}}}}},y=t(76),I=t(223),_=t.n(I),C=t(216),x=t(214),R=t(215),E=t(822),T=t(813),A=t(820),component=Object(y.a)(w,function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-card",{attrs:{flat:""}},[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md6:""}},[t("v-radio-group",{attrs:{mandatory:!1},on:{change:e.select},model:{value:e.token.select,callback:function(n){e.$set(e.token,"select",n)},expression:"token.select"}},[t("v-radio",{attrs:{label:"ERC20 (default)",value:"ERC20"}}),e._v(" "),t("v-radio",{attrs:{label:"ERC20 (burnable)",value:"ERC20Burnable"}}),e._v(" "),t("v-radio",{attrs:{label:"ERC20 (mintable)",value:"ERC20Mintable"}})],1)],1),e._v(" "),t("v-flex",{attrs:{md6:""}},[t("v-text-field",{attrs:{label:"Token Name",readonly:""},model:{value:e.token.name,callback:function(n){e.$set(e.token,"name",n)},expression:"token.name"}}),e._v(" "),t("v-text-field",{attrs:{label:"Token Symbol"},model:{value:e.token.symbol,callback:function(n){e.$set(e.token,"symbol",n)},expression:"token.symbol"}}),e._v(" "),t("v-text-field",{attrs:{label:"Token Initial Supply",type:"number"},model:{value:e.token.initialSupply,callback:function(n){e.$set(e.token,"initialSupply",n)},expression:"token.initialSupply"}})],1)],1)],1)},[],!1,null,null,null),D=component.exports;_()(component,{VCard:C.a,VFlex:x.a,VLayout:R.a,VRadio:E.a,VRadioGroup:T.a,VTextField:A.a});var S="pragma solidity ^0.5.2;\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary Address {\n    /**\n     * Returns whether the target address is a contract\n     * @dev This function will return false if invoked during the constructor of a contract,\n     * as the code is not actually created until after the constructor finishes.\n     * @param account address of the account to check\n     * @return whether the target address is a contract\n     */\n    function isContract(address account) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n}\n",M='pragma solidity ^0.5.2;\n\nimport "../math/SafeMath.sol";\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids\n *\n * Include with `using Counters for Counters.Counter;`\n * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath\n * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never\n * directly accessed.\n */\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library\'s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n',F="pragma solidity ^0.5.2;\n\n/**\n * @title IERC165\n * @dev https://eips.ethereum.org/EIPS/eip-165\n */\ninterface IERC165 {\n    /**\n     * @notice Query if a contract implements an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @dev Interface identification is specified in ERC-165. This function\n     * uses less than 30,000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n",O="pragma solidity ^0.5.2;\n\nimport \"./IERC165.sol\";\n\n/**\n * @title ERC165\n * @author Matt Condon (@shrugs)\n * @dev Implements ERC165 using a lookup table.\n */\ncontract ERC165 is IERC165 {\n    bytes4 private constant _INTERFACE_ID_ERC165 = 0x01ffc9a7;\n    /*\n     * 0x01ffc9a7 ===\n     *     bytes4(keccak256('supportsInterface(bytes4)'))\n     */\n\n    /**\n     * @dev a mapping of interface id to whether or not it's supported\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev A contract implementing SupportsInterfaceWithLookup\n     * implement ERC165 itself\n     */\n    constructor () internal {\n        _registerInterface(_INTERFACE_ID_ERC165);\n    }\n\n    /**\n     * @dev implement supportsInterface(bytes4) using a lookup table\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool) {\n        return _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev internal method for registering an interface\n     */\n    function _registerInterface(bytes4 interfaceId) internal {\n        require(interfaceId != 0xffffffff);\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n",V='pragma solidity ^0.5.2;\n\nimport "../../introspection/IERC165.sol";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) public view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) public view returns (address owner);\n\n    function approve(address to, uint256 tokenId) public;\n    function getApproved(uint256 tokenId) public view returns (address operator);\n\n    function setApprovalForAll(address operator, bool _approved) public;\n    function isApprovedForAll(address owner, address operator) public view returns (bool);\n\n    function transferFrom(address from, address to, uint256 tokenId) public;\n    function safeTransferFrom(address from, address to, uint256 tokenId) public;\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public;\n}\n',N='pragma solidity ^0.5.2;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ncontract IERC721Receiver {\n    /**\n     * @notice Handle the receipt of an NFT\n     * @dev The ERC721 smart contract calls this function on the recipient\n     * after a `safeTransfer`. This function MUST return the function selector,\n     * otherwise the caller will revert the transaction. The selector to be\n     * returned can be obtained as `this.onERC721Received.selector`. This\n     * function MAY throw to revert and reject the transfer.\n     * Note: the ERC721 contract address is always the message sender.\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n     */\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes memory data)\n    public returns (bytes4);\n}\n',P='pragma solidity ^0.5.2;\n\nimport "./IERC721.sol";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Enumerable is IERC721 {\n    function totalSupply() public view returns (uint256);\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256 tokenId);\n\n    function tokenByIndex(uint256 index) public view returns (uint256);\n}\n',$='pragma solidity ^0.5.2;\n\nimport "./IERC721.sol";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n',B='pragma solidity ^0.5.2;\n\nimport "./IERC721.sol";\nimport "./IERC721Receiver.sol";\nimport "../../math/SafeMath.sol";\nimport "../../utils/Address.sol";\nimport "../../drafts/Counters.sol";\nimport "../../introspection/ERC165.sol";\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721 is ERC165, IERC721 {\n    using SafeMath for uint256;\n    using Address for address;\n    using Counters for Counters.Counter;\n\n    // Equals to `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`\n    // which can be also obtained as `IERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant _ERC721_RECEIVED = 0x150b7a02;\n\n    // Mapping from token ID to owner\n    mapping (uint256 => address) private _tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => Counters.Counter) private _ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) private _operatorApprovals;\n\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\n    /*\n     * 0x80ac58cd ===\n     *     bytes4(keccak256(\'balanceOf(address)\')) ^\n     *     bytes4(keccak256(\'ownerOf(uint256)\')) ^\n     *     bytes4(keccak256(\'approve(address,uint256)\')) ^\n     *     bytes4(keccak256(\'getApproved(uint256)\')) ^\n     *     bytes4(keccak256(\'setApprovalForAll(address,bool)\')) ^\n     *     bytes4(keccak256(\'isApprovedForAll(address,address)\')) ^\n     *     bytes4(keccak256(\'transferFrom(address,address,uint256)\')) ^\n     *     bytes4(keccak256(\'safeTransferFrom(address,address,uint256)\')) ^\n     *     bytes4(keccak256(\'safeTransferFrom(address,address,uint256,bytes)\'))\n     */\n\n    constructor () public {\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721);\n    }\n\n    /**\n     * @dev Gets the balance of the specified address\n     * @param owner address to query the balance of\n     * @return uint256 representing the amount owned by the passed address\n     */\n    function balanceOf(address owner) public view returns (uint256) {\n        require(owner != address(0));\n        return _ownedTokensCount[owner].current();\n    }\n\n    /**\n     * @dev Gets the owner of the specified token ID\n     * @param tokenId uint256 ID of the token to query the owner of\n     * @return address currently marked as the owner of the given token ID\n     */\n    function ownerOf(uint256 tokenId) public view returns (address) {\n        address owner = _tokenOwner[tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n     * @dev Approves another address to transfer the given token ID\n     * The zero address indicates there is no approved address.\n     * There can only be one approved address per token at a given time.\n     * Can only be called by the token owner or an approved operator.\n     * @param to address to be approved for the given token ID\n     * @param tokenId uint256 ID of the token to be approved\n     */\n    function approve(address to, uint256 tokenId) public {\n        address owner = ownerOf(tokenId);\n        require(to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    /**\n     * @dev Gets the approved address for a token ID, or zero if no address set\n     * Reverts if the token ID does not exist.\n     * @param tokenId uint256 ID of the token to query the approval of\n     * @return address currently approved for the given token ID\n     */\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId));\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Sets or unsets the approval of a given operator\n     * An operator is allowed to transfer all tokens of the sender on their behalf\n     * @param to operator address to set the approval\n     * @param approved representing the status of the approval to be set\n     */\n    function setApprovalForAll(address to, bool approved) public {\n        require(to != msg.sender);\n        _operatorApprovals[msg.sender][to] = approved;\n        emit ApprovalForAll(msg.sender, to, approved);\n    }\n\n    /**\n     * @dev Tells whether an operator is approved by a given owner\n     * @param owner owner address which you want to query the approval of\n     * @param operator operator address which you want to query the approval of\n     * @return bool whether the given operator is approved by the given owner\n     */\n    function isApprovedForAll(address owner, address operator) public view returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev Transfers the ownership of a given token ID to another address\n     * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n\n        _transferFrom(from, to, tokenId);\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, "");\n    }\n\n    /**\n     * @dev Safely transfers the ownership of a given token ID to another address\n     * If the target address is a contract, it must implement `onERC721Received`,\n     * which is called upon a safe transfer, and return the magic value\n     * `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`; otherwise,\n     * the transfer is reverted.\n     * Requires the msg.sender to be the owner, approved, or operator\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes data to send along with a safe transfer check\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory _data) public {\n        transferFrom(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data));\n    }\n\n    /**\n     * @dev Returns whether the specified token exists\n     * @param tokenId uint256 ID of the token to query the existence of\n     * @return bool whether the token exists\n     */\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        address owner = _tokenOwner[tokenId];\n        return owner != address(0);\n    }\n\n    /**\n     * @dev Returns whether the given spender can transfer a given token ID\n     * @param spender address of the spender to query\n     * @param tokenId uint256 ID of the token to be transferred\n     * @return bool whether the msg.sender is approved for the given token ID,\n     * is an operator of the owner, or is the owner of the token\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to The address that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        require(to != address(0));\n        require(!_exists(tokenId));\n\n        _tokenOwner[tokenId] = to;\n        _ownedTokensCount[to].increment();\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead.\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == owner);\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[owner].decrement();\n        _tokenOwner[tokenId] = address(0);\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(uint256 tokenId) internal {\n        _burn(ownerOf(tokenId), tokenId);\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        require(ownerOf(tokenId) == from);\n        require(to != address(0));\n\n        _clearApproval(tokenId);\n\n        _ownedTokensCount[from].decrement();\n        _ownedTokensCount[to].increment();\n\n        _tokenOwner[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to invoke `onERC721Received` on a target address\n     * The call is not executed if the target address is not a contract\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory _data)\n        internal returns (bool)\n    {\n        if (!to.isContract()) {\n            return true;\n        }\n\n        bytes4 retval = IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, _data);\n        return (retval == _ERC721_RECEIVED);\n    }\n\n    /**\n     * @dev Private function to clear current approval of a given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _clearApproval(uint256 tokenId) private {\n        if (_tokenApprovals[tokenId] != address(0)) {\n            _tokenApprovals[tokenId] = address(0);\n        }\n    }\n}\n',j="pragma solidity ^0.5.2;\n\nimport \"./IERC721Enumerable.sol\";\nimport \"./ERC721.sol\";\nimport \"../../introspection/ERC165.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token with optional enumeration extension logic\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ncontract ERC721Enumerable is ERC165, ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => uint256[]) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_ENUMERABLE = 0x780e9d63;\n    /*\n     * 0x780e9d63 ===\n     *     bytes4(keccak256('totalSupply()')) ^\n     *     bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\n     *     bytes4(keccak256('tokenByIndex(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor () public {\n        // register the supported interface to conform to ERC721Enumerable via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_ENUMERABLE);\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of the tokens list of the requested owner\n     * @param owner address owning the tokens list to be accessed\n     * @param index uint256 representing the index to be accessed of the requested tokens list\n     * @return uint256 token ID at the given index of the tokens list owned by the requested address\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view returns (uint256) {\n        require(index < balanceOf(owner));\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev Gets the total amount of tokens stored by the contract\n     * @return uint256 representing the total amount of tokens\n     */\n    function totalSupply() public view returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev Gets the token ID at a given index of all the tokens in this contract\n     * Reverts if the index is greater or equal to the total number of tokens\n     * @param index uint256 representing the index to be accessed of the tokens list\n     * @return uint256 token ID at the given index of the tokens list\n     */\n    function tokenByIndex(uint256 index) public view returns (uint256) {\n        require(index < totalSupply());\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Internal function to transfer ownership of a given token ID to another address.\n     * As opposed to transferFrom, this imposes no restrictions on msg.sender.\n     * @param from current owner of the token\n     * @param to address to receive the ownership of the given token ID\n     * @param tokenId uint256 ID of the token to be transferred\n     */\n    function _transferFrom(address from, address to, uint256 tokenId) internal {\n        super._transferFrom(from, to, tokenId);\n\n        _removeTokenFromOwnerEnumeration(from, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n    }\n\n    /**\n     * @dev Internal function to mint a new token\n     * Reverts if the given token ID already exists\n     * @param to address the beneficiary that will own the minted token\n     * @param tokenId uint256 ID of the token to be minted\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        super._mint(to, tokenId);\n\n        _addTokenToOwnerEnumeration(to, tokenId);\n\n        _addTokenToAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        _removeTokenFromOwnerEnumeration(owner, tokenId);\n        // Since tokenId will be deleted, we can clear its slot in _ownedTokensIndex to trigger a gas refund\n        _ownedTokensIndex[tokenId] = 0;\n\n        _removeTokenFromAllTokensEnumeration(tokenId);\n    }\n\n    /**\n     * @dev Gets the list of token IDs of the requested owner\n     * @param owner address owning the tokens\n     * @return uint256[] List of token IDs owned by the requested address\n     */\n    function _tokensOfOwner(address owner) internal view returns (uint256[] storage) {\n        return _ownedTokens[owner];\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;\n        _ownedTokens[to].push(tokenId);\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the _ownedTokensIndex mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _ownedTokens[from].length.sub(1);\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        _ownedTokens[from].length--;\n\n        // Note that _ownedTokensIndex[tokenId] hasn't been cleared: it still points to the old slot (now occupied by\n        // lastTokenId, or just over the end of the array if the token was the last one).\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length.sub(1);\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        _allTokens.length--;\n        _allTokensIndex[tokenId] = 0;\n    }\n}\n",z="pragma solidity ^0.5.2;\n\nimport \"./ERC721.sol\";\nimport \"./IERC721Metadata.sol\";\nimport \"../../introspection/ERC165.sol\";\n\ncontract ERC721Metadata is ERC165, ERC721, IERC721Metadata {\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    bytes4 private constant _INTERFACE_ID_ERC721_METADATA = 0x5b5e139f;\n    /*\n     * 0x5b5e139f ===\n     *     bytes4(keccak256('name()')) ^\n     *     bytes4(keccak256('symbol()')) ^\n     *     bytes4(keccak256('tokenURI(uint256)'))\n     */\n\n    /**\n     * @dev Constructor function\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n\n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(_INTERFACE_ID_ERC721_METADATA);\n    }\n\n    /**\n     * @dev Gets the token name\n     * @return string representing the token name\n     */\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Gets the token symbol\n     * @return string representing the token symbol\n     */\n    function symbol() external view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns an URI for a given token ID\n     * Throws if the token ID does not exist. May return an empty string.\n     * @param tokenId uint256 ID of the token to query\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId));\n        return _tokenURIs[tokenId];\n    }\n\n    /**\n     * @dev Internal function to set the token URI for a given token\n     * Reverts if the token ID does not exist\n     * @param tokenId uint256 ID of the token to set its URI\n     * @param uri string URI to assign\n     */\n    function _setTokenURI(uint256 tokenId, string memory uri) internal {\n        require(_exists(tokenId));\n        _tokenURIs[tokenId] = uri;\n    }\n\n    /**\n     * @dev Internal function to burn a specific token\n     * Reverts if the token does not exist\n     * Deprecated, use _burn(uint256) instead\n     * @param owner owner of the token to burn\n     * @param tokenId uint256 ID of the token being burned by the msg.sender\n     */\n    function _burn(address owner, uint256 tokenId) internal {\n        super._burn(owner, tokenId);\n\n        // Clear metadata (if any)\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n",U=v(window.Module),L={ERC721:{"IERC721.sol":{content:V},"IERC721Receiver.sol":{content:N},"IERC721Enumerable.sol":{content:P},"IERC721Metadata.sol":{content:$},"math/SafeMath.sol":{content:r},"utils/Address.sol":{content:S},"drafts/Counters.sol":{content:M},"introspection/IERC165.sol":{content:F},"introspection/ERC165.sol":{content:O},"ERC721.sol":{content:B},"ERC721Enumerable.sol":{content:j},"ERC721Metadata.sol":{content:z},Deploy:{content:""}},ERC721Burnable:{"IERC721.sol":{content:V},"IERC721Receiver.sol":{content:N},"IERC721Enumerable.sol":{content:P},"IERC721Metadata.sol":{content:$},"math/SafeMath.sol":{content:r},"utils/Address.sol":{content:S},"drafts/Counters.sol":{content:M},"introspection/IERC165.sol":{content:F},"introspection/ERC165.sol":{content:O},"ERC721.sol":{content:B},"ERC721Enumerable.sol":{content:j},"ERC721Metadata.sol":{content:z},"ERC721Burnable.sol":{content:'pragma solidity ^0.5.2;\n\nimport "./ERC721.sol";\n\n/**\n * @title ERC721 Burnable Token\n * @dev ERC721 Token that can be irreversibly burned (destroyed).\n */\ncontract ERC721Burnable is ERC721 {\n    /**\n     * @dev Burns a specific ERC721 token.\n     * @param tokenId uint256 id of the ERC721 token to be burned.\n     */\n    function burn(uint256 tokenId) public {\n        require(_isApprovedOrOwner(msg.sender, tokenId));\n        _burn(tokenId);\n    }\n}\n'},Deploy:{content:""}},ERC721Mintable:{"IERC721.sol":{content:V},"IERC721Receiver.sol":{content:N},"IERC721Enumerable.sol":{content:P},"IERC721Metadata.sol":{content:$},"math/SafeMath.sol":{content:r},"utils/Address.sol":{content:S},"drafts/Counters.sol":{content:M},"introspection/IERC165.sol":{content:F},"introspection/ERC165.sol":{content:O},"ERC721.sol":{content:B},"ERC721Enumerable.sol":{content:j},"ERC721Metadata.sol":{content:z},"access/Roles.sol":{content:d},"access/roles/MinterRole.sol":{content:l},"ERC721Mintable.sol":{content:'pragma solidity ^0.5.2;\n\nimport "./ERC721.sol";\nimport "../../access/roles/MinterRole.sol";\n\n/**\n * @title ERC721Mintable\n * @dev ERC721 minting logic\n */\ncontract ERC721Mintable is ERC721, MinterRole {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param tokenId The token id to mint.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 tokenId) public onlyMinter returns (bool) {\n        _mint(to, tokenId);\n        return true;\n    }\n}\n'},Deploy:{content:""}}},G={data:function(){return{token:{select:"ERC721",name:"My Token",symbol:"XMT",byteCode:null,output:null}}},methods:{select:function(){var e=Object(o.a)(regeneratorRuntime.mark(function e(n){return regeneratorRuntime.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:case"end":return e.stop()}},e)}));return function(n){return e.apply(this,arguments)}}(),customize:function(){var base=this.token.select,e=L[base];return e.Deploy.content="\n        pragma solidity ^0.5.2;\n        import './".concat(base,'.sol\';\n        import "./ERC721Enumerable.sol";\n        import "./ERC721Metadata.sol";\n        contract My').concat(base," is ").concat(base,', ERC721Enumerable, ERC721Metadata {\n            constructor () public ERC721Metadata("').concat(this.token.name,'", "').concat(this.token.symbol,'") {}\n        }'),e},compile:function(){var e={language:"Solidity",sources:this.customize(),settings:{optimizer:{enabled:!0,runs:200},outputSelection:{"*":{"*":["*"]}}}},output=JSON.parse(U.compile(JSON.stringify(e)));return this.token.byteCode="0x"+output.contracts.Deploy["My".concat(this.token.select)].evm.bytecode.object,{abi:output.contracts.Deploy["My".concat(this.token.select)].abi,option:{data:this.token.byteCode}}}}},J=Object(y.a)(G,function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-card",{attrs:{flat:""}},[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md6:""}},[t("v-radio-group",{attrs:{mandatory:!1},on:{change:e.select},model:{value:e.token.select,callback:function(n){e.$set(e.token,"select",n)},expression:"token.select"}},[t("v-radio",{attrs:{label:"ERC721 (default)",value:"ERC721"}}),e._v(" "),t("v-radio",{attrs:{label:"ERC721 (burnable)",value:"ERC721Burnable"}}),e._v(" "),t("v-radio",{attrs:{label:"ERC721 (mintable)",value:"ERC721Mintable"}})],1)],1),e._v(" "),t("v-flex",{attrs:{md6:""}},[t("v-text-field",{attrs:{label:"Token Name",readonly:""},model:{value:e.token.name,callback:function(n){e.$set(e.token,"name",n)},expression:"token.name"}}),e._v(" "),t("v-text-field",{attrs:{label:"Token Symbol"},model:{value:e.token.symbol,callback:function(n){e.$set(e.token,"symbol",n)},expression:"token.symbol"}})],1)],1)],1)},[],!1,null,null,null),K=J.exports;_()(J,{VCard:C.a,VFlex:x.a,VLayout:R.a,VRadio:E.a,VRadioGroup:T.a,VTextField:A.a});var Q={props:{address:{type:String,required:!0},dialog:{type:Object,required:!0}},data:function(){return{valid:null,title:"",agrs:[],notEmpty:[function(e){return!!e||"Required."}],result:"",btn:"RUN"}},mounted:function(){this.title=this.dialog.name,this.agrs=[];for(var i=0;i<this.dialog.obj.inputs.length;i++)this.agrs.push({model:"",label:this.dialog.obj.inputs[i].type+" "+this.dialog.obj.inputs[i].name});this.btn=this.dialog.obj.constant?"Call":"Send"},methods:{estimateGas:function(){if(this.$refs.form.validate()){this.result="";try{var e=window.wallet.abiQR.encodeFunctionCall({to:this.address,json:this.dialog.obj,parms:this.agrs}),n=this;this.$emit("estimateGas",{callData:{to:e.to,data:e.code},callback:function(t,o){n.result=t?JSON.stringify(t,null,2):JSON.stringify({byteCode:e.code,estimateGas:o},null,2)}})}catch(e){this.result=JSON.stringify(e,null,2)}}},run:function(){if(this.$refs.form.validate()){var e=window.wallet.abiQR.encodeFunctionCall({to:this.address,json:this.dialog.obj,parms:this.agrs});if(this.dialog.obj.constant){var n=this;this.$emit("call",{callData:{to:e.to,data:e.code},callback:function(e,t){e||(n.result=JSON.stringify(window.wallet.web3.eth.abi.decodeParameters(n.dialog.obj.outputs,t),null,2))}})}else{var t=this;this.$emit("send",{callData:{to:e.to,data:e.code},callback:function(e,n){e||(t.result=JSON.stringify(window.wallet.web3.eth.abi.decodeParameters(t.dialog.obj.outputs,n),null,2))}})}}}}},X=(t(793),t(217)),Y=t(209),W=t(210),H=t(814),Z=t(751),ee=t(790),ne=Object(y.a)(Q,function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-card",[t("v-card-title",{attrs:{"primary-title":""}},[t("span",{staticClass:"mono font-weight-medium"},[e._v("\n      "+e._s(e.title)+"\n    ")])]),e._v(" "),t("v-container",{attrs:{fluid:""}},[t("v-form",{ref:"form",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[e._l(e.agrs,function(n,o){return t("v-text-field",{key:o,staticClass:"mono",attrs:{label:n.label,rules:e.notEmpty,required:""},on:{input:e.estimateGas},model:{value:n.model,callback:function(t){e.$set(n,"model",t)},expression:"item.model"}})}),e._v(" "),t("v-textarea",{staticClass:"mono mt-2",attrs:{readonly:"",outline:"",label:e.dialog.returns,value:e.result}})],2)],1),e._v(" "),"function"==e.dialog.obj.type?t("v-layout",[t("v-spacer"),e._v(" "),t("v-btn",{attrs:{flat:""},on:{click:function(n){return n.stopPropagation(),e.$emit("hide")}}},[e._v("\n      Close\n    ")]),e._v(" "),t("v-btn",{attrs:{flat:""},on:{click:function(n){return n.stopPropagation(),e.run(n)}}},[e._v("\n      "+e._s(e.btn)+"\n    ")])],1):e._e()],1)},[],!1,null,"5efd9761",null),te=ne.exports;_()(ne,{VBtn:X.a,VCard:C.a,VCardTitle:Y.a,VContainer:W.a,VForm:H.a,VLayout:R.a,VSpacer:Z.a,VTextField:A.a,VTextarea:ee.a});var oe={data:function(){return{valid:null,address:"",cf:[],ncf:[],e:[],abi:[],source:{},contract:{show:!1,name:"",compiler:"",optimization:"",runs:"",code:"",swarm:"",abi:""},dialog:{run:!1,fullName:"",body:null,obj:null},rules:{isAddress:function(e){return window.wallet.isAddress(e)||"Is not address."}}}},methods:{load:function(){var e=this;this.$refs.formContract.validate()&&(this.contract.name="",this.contract.compiler="",this.contract.optimization="",this.contract.runs="",this.contract.code="",this.contract.swarm="",this.contract.abi="",window.wallet.logs.loadSource(web3.currentProvider.networkVersion,this.address).catch(console.log).then(function(n){n.length>0?(e.source=n[0],e.contract.name=e.source.ContractName,e.contract.compiler=e.source.CompilerVersion,e.contract.optimization="1"===e.source.OptimizationUsed?"true":"false",e.contract.runs=e.source.Runs,e.contract.code=e.source.SourceCode,e.contract.swarm=e.source.SwarmSource,e.createInterface()):window.wallet.logs.loadABI(web3.currentProvider.networkVersion,e.address).catch(console.log).then(function(n){e.source.ABI=n,e.createInterface()})}))},createInterface:function(){this.abi=JSON.parse(this.source.ABI),this.contract.abi=JSON.stringify(this.abi,null,2),this.ui=[];for(var i=0;i<this.abi.length;i++)this.create(this.abi[i])},arguments:function(e){var n="";if(void 0!==e)for(var i=0;i<e.length;i++)n+=(i>0?", ":"")+e[i].type+(void 0!==e[i].indexed&&e[i].indexed?" indexed":"")+(""!==e[i].name?" "+e[i].name:"");return"("+n+")"},getName:function(e){return e.name+this.arguments(e.inputs)},create:function(e){var title=e.type+" "+this.getName(e);switch(e.type){case"function":var n=this.arguments(e.outputs);n="()"===n?"":(e.payable?" returns ":"returns ")+n,e.constant?this.cf.push({title:title,returns:n,payable:e.payable,obj:e}):this.ncf.push({title:title,returns:n,payable:e.payable,obj:e});break;case"event":this.e.push({title:title,obj:e});break;default:console.log(e)}},runNCF:function(e){this.dialog.name=this.getName(e),this.dialog.fullName=e.type+" "+this.dialog.name,this.dialog.obj=e,this.dialog.body=te,this.dialog.returns="Estimate gas",this.dialog.show=!this.dialog.show},runCF:function(e){this.dialog.name=this.getName(e),this.dialog.fullName=e.type+" "+this.dialog.name,this.dialog.obj=e,this.dialog.body=te,this.dialog.returns="returns "+this.arguments(e.outputs),this.dialog.show=!this.dialog.show},runEvent:function(e){var n="topic0="+window.wallet.abiQR.encodeEventSignature(e);window.wallet.logs.getLogs(web3.currentProvider.networkVersion,this.address,n).catch(console.log).then(console.log)},getUrl:function(e){var n="topic0="+window.wallet.abiQR.encodeEventSignature(e);return window.wallet.logs.getUrl(web3.currentProvider.networkVersion,this.address,n)}}},ae=(t(797),t(815)),re=t(821),se=t(816),ie=t(817),de=t(818),le=t(212),ce=t(213),ue=t(754),pe=Object(y.a)(oe,function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md4:"",xs12:""}},[t("div",{staticClass:"headline font-weight-light"},[e._v("\n        Contract\n      ")])]),e._v(" "),t("v-flex",{attrs:{md8:"",xs12:""}},[t("v-form",{ref:"formContract",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[t("v-text-field",{staticClass:"mono",attrs:{label:"Contract Address",rules:[e.rules.isAddress]},model:{value:e.address,callback:function(n){e.address=n},expression:"address"}}),e._v(" "),t("v-layout",{attrs:{"justify-end":""}},[t("v-btn",{attrs:{flat:""},on:{click:function(n){return n.stopPropagation(),e.load()}}},[e._v("\n            Load\n          ")])],1)],1)],1)],1),e._v(" "),t("v-divider",{staticClass:"mb-3 mt-3"}),e._v(" "),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md4:"",xs12:""}},[t("div",{staticClass:"headline font-weight-light"},[e._v("\n        Source\n      ")])]),e._v(" "),t("v-flex",{attrs:{md8:"",xs12:""}},[t("v-form",[t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Contract Name"},model:{value:e.contract.name,callback:function(n){e.$set(e.contract,"name",n)},expression:"contract.name"}})],1),e._v(" "),t("v-flex",{attrs:{md6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Optimization Enabled"},model:{value:e.contract.optimization,callback:function(n){e.$set(e.contract,"optimization",n)},expression:"contract.optimization"}})],1),e._v(" "),t("v-flex",{attrs:{md6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Compiler Version"},model:{value:e.contract.compiler,callback:function(n){e.$set(e.contract,"compiler",n)},expression:"contract.compiler"}})],1),e._v(" "),t("v-flex",{attrs:{md6:""}},[t("v-text-field",{attrs:{readonly:"",label:"Runs (Optimizer)"},model:{value:e.contract.runs,callback:function(n){e.$set(e.contract,"runs",n)},expression:"contract.runs"}})],1)],1)],1),e._v(" "),t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Source\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-text-field",{staticClass:"mono",attrs:{readonly:"",label:"Swarm Source"},model:{value:e.contract.swarm,callback:function(n){e.$set(e.contract,"swarm",n)},expression:"contract.swarm"}}),e._v(" "),t("v-textarea",{staticClass:"mono-small",attrs:{readonly:"",outline:"",rows:"25",label:"Contract Source Code",value:e.contract.code}})],1)],1)],1)],1)],1),e._v(" "),t("v-divider",{staticClass:"mb-3 mt-3"}),e._v(" "),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md4:"",xs12:""}},[t("div",{staticClass:"headline font-weight-light mb-3"},[e._v("\n        ABI\n      ")])]),e._v(" "),t("v-flex",{attrs:{md8:"",xs12:""}},[t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Json\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-textarea",{staticClass:"mono-small",attrs:{readonly:"",outline:"",rows:"10",label:"Contract ABI",value:e.contract.abi}})],1)],1),e._v(" "),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Function\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-list",{attrs:{"two-line":"",subheader:""}},e._l(e.ncf,function(n,o){return t("v-list-tile",{key:o,on:{click:function(t){return e.runNCF(n.obj)}}},[t("v-list-tile-content",[t("v-list-tile-title",{staticClass:"mono"},[e._v("\n                    "+e._s(n.title)+"\n                  ")]),e._v(" "),t("v-list-tile-sub-title",[n.payable?t("v-chip",{attrs:{label:"",disabled:"",color:"red","text-color":"white"}},[e._v("\n                      Payable\n                    ")]):e._e(),e._v(" "),t("span",{staticClass:"mono"},[e._v("\n                      "+e._s(n.returns)+"\n                    ")])],1)],1)],1)}),1)],1)],1),e._v(" "),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Constant Function\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-list",{attrs:{"two-line":"",subheader:""}},e._l(e.cf,function(n,o){return t("v-list-tile",{key:o,on:{click:function(t){return e.runCF(n.obj)}}},[t("v-list-tile-content",[t("v-list-tile-title",{staticClass:"mono"},[e._v("\n                    "+e._s(n.title)+"\n                  ")]),e._v(" "),t("v-list-tile-sub-title",[n.payable?t("v-chip",{attrs:{label:"",disabled:"",color:"red","text-color":"white"}},[e._v("\n                      Payable\n                    ")]):e._e(),e._v(" "),t("span",{staticClass:"mono"},[e._v("\n                      "+e._s(n.returns)+"\n                    ")])],1)],1)],1)}),1)],1)],1),e._v(" "),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Event\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-list",{attrs:{"two-line":"",subheader:""}},e._l(e.e,function(n,o){return t("v-list-tile",{key:o,attrs:{href:e.getUrl(n.obj),target:"_blank"}},[t("v-list-tile-content",[t("v-list-tile-title",{staticClass:"mono"},[e._v("\n                    "+e._s(n.title)+"\n                  ")]),e._v(" "),t("v-list-tile-sub-title",{staticClass:"mono"},[e._v("\n                    "+e._s(n.returns)+"\n                  ")])],1)],1)}),1)],1)],1)],1)],1)],1),e._v(" "),t("v-divider",{staticClass:"mb-3 mt-3"}),e._v(" "),t("v-dialog",{attrs:{persistent:"","max-width":"640"},model:{value:e.dialog.show,callback:function(n){e.$set(e.dialog,"show",n)},expression:"dialog.show"}},[t(e.dialog.body,{tag:"component",attrs:{address:e.address,dialog:e.dialog},on:{hide:function(n){e.dialog.show=!1,e.dialog.body=null,e.dialog.obj=null},call:function(n){return e.$emit("call",n)},send:function(n){return e.$emit("send",n)},estimateGas:function(n){return e.$emit("estimateGas",n)}}})],1)],1)},[],!1,null,"76b38192",null),me=pe.exports;_()(pe,{VBtn:X.a,VChip:ae.a,VContainer:W.a,VDialog:re.a,VDivider:se.a,VExpansionPanel:ie.a,VExpansionPanelContent:de.a,VFlex:x.a,VForm:H.a,VLayout:R.a,VList:le.a,VListTile:ce.a,VListTileContent:ue.a,VListTileSubTitle:ue.b,VListTileTitle:ue.c,VTextField:A.a,VTextarea:ee.a});var fe={components:{ERC20:D,ERC721:K,ABI:me},data:function(){return{valid:null,loading:!1,enable:!1,member:{issuers:0,accounts:0},create:{master:"",payment:"",verify:"",uid:"",account:""},add:{proxyKey:"",account:""},remove:{proxyKey:"",account:""},rules:{isAddress:function(e){return window.wallet.isAddress(e)||"Is not address."},min:function(e){return e.length>=4||"Min 4 characters"}}}},mounted:function(){var e=this;web3&&"3"===web3.currentProvider.networkVersion.toString()&&(this.enable=!0,web3.eth.call({to:window.wallet.daoAuth.address,data:window.wallet.daoAuth.methods.accounts().encodeABI()},function(n,t){n||(t=window.wallet.web3.eth.abi.decodeParameters(["uint256","uint256"],t),e.member.issuers=window.wallet.web3.utils.toBN(t[0]).toString(),e.member.accounts=window.wallet.web3.utils.toBN(t[1]).toString())}))},methods:{sendTransaction:function(e,data){var n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;web3.currentProvider.selectedAddress&&web3.eth.sendTransaction({from:web3.currentProvider.selectedAddress,to:e,data:data},function(e,t){console.log(e,t),!e&&n&&n(t)})},createIssuer:function(){if(this.$refs.formCreate.validate()&&this.enable){var e=window.wallet.web3.utils.keccak256(this.create.uid);this.sendTransaction(window.wallet.daoAuth.address,window.wallet.daoAuth.methods.create([this.create.master,this.create.payment,this.create.verify],e).encodeABI())}},addProxy:function(){this.$refs.formAdd.validate()&&this.enable&&this.sendTransaction(window.wallet.daoAuth.address,window.wallet.daoAuth.methods.proxyAdd(this.add.account,this.add.proxyKey).encodeABI())},removeProxy:function(){this.$refs.formRemove.validate()&&this.enable&&this.sendTransaction(window.wallet.daoAuth.address,window.wallet.daoAuth.methods.proxyRemove(this.remove.account,this.remove.proxyKey).encodeABI())},deploy:function(e){this.sendTransaction(null,new window.wallet.web3.eth.Contract(e.abi).deploy(e.option).encodeABI())},createErc20:function(){this.deploy(this.$refs.erc20.compile())},createErc721:function(){this.deploy(this.$refs.erc721.compile())},estimateGas:function(data){web3.eth.estimateGas(data.callData,data.callback)},call:function(data){web3.eth.call(data.callData,data.callback)},send:function(data){this.sendTransaction(data.callData.to,data.callData.data,data.callback)}}},ve=(t(811),Object(y.a)(fe,function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("v-container",[t("h1",{staticClass:"white--text font-weight-light display-1 mt-5 text-xs-center"},[e._v("\n    DaoAuth\n  ")]),e._v(" "),t("v-divider",{staticClass:"mb-3 mt-3"}),e._v(" "),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md4:""}},[t("div",{staticClass:"headline font-weight-light"},[e._v("\n        Issuer Account\n      ")]),e._v(" "),t("div",{staticClass:"body-2 mb-3 font-weight-thin"},[e._v("\n        "+e._s(e.member.issuers)+"/"+e._s(e.member.accounts)+"\n      ")])]),e._v(" "),t("v-flex",{attrs:{md8:""}},[t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Create Issuer Account\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-form",{ref:"formCreate",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[t("v-text-field",{staticClass:"address-small",attrs:{label:"Master",rules:[e.rules.isAddress],disabled:!e.enable},model:{value:e.create.master,callback:function(n){e.$set(e.create,"master",n)},expression:"create.master"}}),e._v(" "),t("v-text-field",{staticClass:"address-small",attrs:{label:"Payment",rules:[e.rules.isAddress],disabled:!e.enable},model:{value:e.create.payment,callback:function(n){e.$set(e.create,"payment",n)},expression:"create.payment"}}),e._v(" "),t("v-text-field",{staticClass:"address-small",attrs:{label:"Verify",rules:[e.rules.isAddress],disabled:!e.enable},model:{value:e.create.verify,callback:function(n){e.$set(e.create,"verify",n)},expression:"create.verify"}}),e._v(" "),t("v-text-field",{staticClass:"address-small",attrs:{label:"UID",rules:[e.rules.min],disabled:!e.enable},model:{value:e.create.uid,callback:function(n){e.$set(e.create,"uid",n)},expression:"create.uid"}}),e._v(" "),t("v-text-field",{staticClass:"address-small",attrs:{label:"Account",loading:e.loading,disabled:!e.enable,readonly:""},model:{value:e.create.account,callback:function(n){e.$set(e.create,"account",n)},expression:"create.account"}}),e._v(" "),t("v-spacer"),t("v-spacer"),t("v-spacer")],1),e._v(" "),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:"",disabled:!e.enable},on:{click:e.createIssuer}},[e._v("\n                Create\n              ")])],1)],1)],1),e._v(" "),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Add Issuer Proxy Keys\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-form",{ref:"formAdd",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[t("v-text-field",{staticClass:"address-small",attrs:{label:"Account",rules:[e.rules.isAddress],disabled:!e.enable},model:{value:e.add.account,callback:function(n){e.$set(e.add,"account",n)},expression:"add.account"}}),e._v(" "),t("v-text-field",{staticClass:"address-small",attrs:{label:"UID",rules:[e.rules.isAddress],disabled:!e.enable},model:{value:e.add.proxyKey,callback:function(n){e.$set(e.add,"proxyKey",n)},expression:"add.proxyKey"}})],1),e._v(" "),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:"",disabled:!e.enable},on:{click:e.addProxy}},[e._v("\n                Add\n              ")])],1)],1)],1),e._v(" "),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              Remove Issuer Proxy Keys\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("v-form",{ref:"formRemove",attrs:{"lazy-validation":""},model:{value:e.valid,callback:function(n){e.valid=n},expression:"valid"}},[t("v-text-field",{staticClass:"address-small",attrs:{label:"Account",rules:[e.rules.isAddress],disabled:!e.enable},model:{value:e.remove.account,callback:function(n){e.$set(e.remove,"account",n)},expression:"remove.account"}}),e._v(" "),t("v-text-field",{staticClass:"address-small",attrs:{label:"UID",rules:[e.rules.isAddress],disabled:!e.enable},model:{value:e.remove.proxyKey,callback:function(n){e.$set(e.remove,"proxyKey",n)},expression:"remove.proxyKey"}})],1),e._v(" "),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:"",disabled:!e.enable},on:{click:e.removeProxy}},[e._v("\n                Remove\n              ")])],1)],1)],1)],1)],1)],1),e._v(" "),t("v-divider",{staticClass:"mb-5 mt-3"}),e._v(" "),t("h1",{staticClass:"white--text font-weight-light display-1 text-xs-center"},[e._v("\n    FACTORY\n  ")]),e._v(" "),t("v-divider",{staticClass:"mb-3 mt-3"}),e._v(" "),t("v-layout",{attrs:{row:"",wrap:""}},[t("v-flex",{attrs:{md4:"",xs12:""}},[t("div",{staticClass:"headline mb-3 font-weight-light"},[e._v("\n        Token Factory\n      ")])]),e._v(" "),t("v-flex",{attrs:{md8:"",xs12:""}},[t("v-expansion-panel",[t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              ERC 20\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("ERC20",{ref:"erc20"}),e._v(" "),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:""},on:{click:e.createErc20}},[e._v("\n                Create\n              ")])],1)],1)],1),e._v(" "),t("v-expansion-panel-content",{scopedSlots:e._u([{key:"header",fn:function(){return[t("div",{staticClass:"title font-weight-light"},[e._v("\n              ERC 721\n            ")])]},proxy:!0}])},[e._v(" "),t("v-container",[t("ERC721",{ref:"erc721"}),e._v(" "),t("div",{staticClass:"text-xs-right"},[t("v-btn",{attrs:{flat:""},on:{click:e.createErc721}},[e._v("\n                Create\n              ")])],1)],1)],1)],1)],1)],1),e._v(" "),t("v-divider",{staticClass:"mb-5 mt-3"}),e._v(" "),t("h1",{staticClass:"white--text font-weight-light display-1 text-xs-center"},[e._v("\n    CODE\n  ")]),e._v(" "),t("v-divider",{staticClass:"mb-3 mt-3"}),e._v(" "),t("ABI",{ref:"abi",on:{call:e.call,send:e.send,estimateGas:e.estimateGas}})],1)},[],!1,null,"7a1dbada",null));n.default=ve.exports;_()(ve,{VBtn:X.a,VContainer:W.a,VDivider:se.a,VExpansionPanel:ie.a,VExpansionPanelContent:de.a,VFlex:x.a,VForm:H.a,VLayout:R.a,VSpacer:Z.a,VTextField:A.a})}}]);